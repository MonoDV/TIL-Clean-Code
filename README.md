# TIL-Clean-Code

> 클린 코드 내용 요약 정리

---

## 1장 깨끗한 코드

깨끗한 코드란 무엇인가?

### 핵심

**나쁜 코드** 가 쌓이면 쌓일수록, **생산성** 은 떨어진다.

### 나쁜 코드로 치르는 대가

-   코드를 고칠 때마다 문제가 발생함
-   스파게티 코드를 **해독** 하느라 오랜 시간이 걸린다
-   얽히고 설킨 코드를 더욱 쌓게된다

#### 결국 시스템을 다시 설계하려면 막대한 비용이 든다

> 빨리 가려면 깨끗한 코드를 유지해야 한다.
> `그렇다면 깨끗한 코드를 작성하는 방법은 무엇일까?`

### 많은 프로그래머들이 생각하는 깨끗한 코드의 요소

-   논리가 간단해야 버그가 숨어들지 못한다
-   오류는 명백한 전략에 의거해 철저히 처리
-   깨끗한 코드는 잘 쓴 문장처럼 읽힌다
-   설계자의 의도를 숨기지 않는다
-   모든 테스트를 통과한다
-   중복이 없다
-   클래스, 메서드, 함수 등을 최대한 줄인다.

### 이 후의 내용은, 이 책의 저자가 생각하는 '깨끗한 코드'에 대한 내용이다.

---

## 2장 의미있는 이름

클린한 코드를 작성하기 위한 이름을 정하는 기본적인 가이드라인.

### 핵심 요약

-   이름을 보고 의도를 알 수 있어야함
-   이름에서 오해할만한 잘못된 정보를 제공하면 안됨
-   기존에 사용하던 이름과 비슷한 이름을 사용해서 헷갈리게 하지 마라
-   축약어같이 발음하기 어려운 이름은 피하라
-   나중에 검색하기 쉽도록 하라
-   가급적 인코딩은 피하라
-   자신의 지식을 자랑하지 말고 모두가 이해할 수 있는 이름을 사용하라
-   클래스 명명규칙, 메서드 명명규칙에 차이가 있으니 잘 확인해볼것
-   이름에 특정 문화의 용어 사용 지양
-   한 개념에 한 단어 사용 (get, retrieve, fetch)
-   위의 내용을 보고 일관성을 유지하려다가 비슷한 다른 개념을 한 단어로 표현하지 마라 (add / insert / append)
-   해법 영역 혹은 문제 영역에서 이름을 가져와라
-   불필요한 맥락을 없애라

### 단락

-   의도를 분명히 밝혀라
    -   int d; // 경과 시간(댠위:날짜) :x:
    -   int elapsedTimeInDays; :white_check_mark:
-   그릇된 정보를 피하라
    -   List 자료형이 아닌데 accountList라고 명명 :x: -> 사실 이름에 List도 쓰지 않는데 이는 뒤에서 다룬다
    -   흡사한 이름을 사용하지 말라
        -   XYZControllerForEfficientStorageOfStrings
        -   XYZControllerForEfficientHandlingOfStrings
-   의미있게 구분하라
    -   컴파일을 통과하기 위해 명명하는 경우 ex) klass...
    -   불용어를 붙이는 경우
        -   a1, a2, a3, ... :x:
        -   Product클래스 작성 후 ProductInfo, ProductData :x: -> Info, Data는 아무 의미도 제공하지 못함
        -   getAccount(), getAccounts(), getAccountList() :x: -> 어떤 메서드를 호출해야 할 지 모름
-   발음하기 쉬운 이름을 사용하라
    -   genymdhms(generate date, year, monthj, day, hour, minute, second) :x:
    -   generationTimestamp :white_check_mark:
-   검색하기 쉬운 이름을 사용하라
    -   grep으로 찾기 쉽도록 숫자 등을 상수로 명명
    -   5 -> const int WORK_DAYS_PER_WEEK = 5 :white_check_mark:
-   인코딩을 피하라
    -   접두어를 사용하는 것
        -   멤버 변수 앞에 `m_`으로 시작하는 접두어 사용 :x:
        -   인터페이스 이름 앞에 "I"로 시작하는 접두어 사용 -> 필자는 추천하지 않음
            -   인코딩이 필요하다고 생각되는 경우 차라리 구현체에 "Imp" 접미사를 붙이는 선호
-   자신의 기억력을 시험하지 마라
    -   LOS라는 이름이 Line of sight를 의미한다는 것을 알고 있다고 줄여쓰지 마라
    -   모두가 이해할 수 있도록 명료하게
-   클래스 이름
    -   명사나 명사구가 적합
    -   Customer, WikiPage, Account, AddressParser :white_check_mark:
    -   Manager, Processor, Data, Info :x:
-   메서드 이름
    -   동사나 동사구가 적합
    -   postPayment, deletePage, save :white_check_mark:
    -   생성자 중복정의시, 정적 팩토리 메서드 사용
        -   Complex fulcrumPoint = Complex.FromRealNumber(23.0); :thumbsup:
        -   Complex fulcrumPoint = new Complex(23.0); -> 나쁘진 않지만 위의 방법을 추천
-   기발한 이름은 피하라
    -   웃기자고 특정 문화에서 사용하는 농담을 사용하는것은 지양하라
-   한 개념에 한 단어를 사용하라
    -   똑같은 메서드를 클래스마다 fetch, retrieve, get처럼 제각각으로 부르는 것 :x:
    -   마찬가지로 controller, manager, driver를 혼재하여 사용 :x:
-   말장난을 하지 마라 (일관성을 잘못 적용하지 마라)
    -   산술 연산에 add라는 이름을 사용
    -   집합에 값 하나를 추가하는데 add 사용 :x: -> insert나 append를 사용하라
-   해법 영역에서 가져온 이름을 사용하라
    -   프로그래머에게 익숙한 기술 개념은 많다. 기술 개념에는 기술 이름을 선택하라
    -   JobQueue, AccontVisitor :white_check_mark:
-   문제 영역에서 가져온 이름을 사용하라
    -   적절한 '프로그래머 용어'가 없다면 문제 영역에서 이름을 가져온다
    -   문제 영역 개념과 관련이 깊은 경우에도 사용
-   의미 있는 맥락을 추가하라
    -   city, zipcode, state라는 변수가 있을 경우 state가 주소 일부라는 것을 알 수 있음
    -   그러나 어떤 메서드에서 state만 사용한다면 무슨 의미인지 파악하는것이 어렵다
    -   addrState로 변경 시 해결, 또는 Address 클래스를 추가하면 더욱 좋다
    -   Address가 IP 주소인지, 집 주소인지 헷갈릴 수 있으므로 PostalAddress로 할 수도 있겠다
-   불필요한 맥락을 없애라

    -   의미가 분명한 경우, 이름에 불필요한 맥락 추가 :x:
    -   Gas Station Deluxe라는 어플리케이션 개발을 위해 모든 클래스 이름을 'GSD'로 시작하겠다는 생각은 :x:

---

## 3장 함수

함수를 잘 만드는 방법

### 핵심

-   작게 만들기
-   함수는 같은 추상화 수준을 유지 ex) 클래스에서 높은 추상화 수준은 public, 낮은 추상화 수준은 private이 되겠다
-   인수는 적을수록 좋다
-   함수가 몰래 하는 일이 없도록 한다
-   예외 활용
-   반복 절대 금지
-   계속 다듬으면서 리팩토링 하는게 답이다

### 단락

-   작게 만들어라
    -   함수의 들여쓰기 수준은 1단이나 2단을 넘어가선 안된다
    -   20줄도 긴 편이다
    -   더 작게 만들어라
-   함수가 한 가지만 하도록 해라
    -   함수 당 추상화 수준은 한 가지로 해라
    -   함수 내에서 의미 있는 다른 이름으로 함수를 추출할 수 있다면 여러 작업을 하는 셈이다
    -   switch문의 경우 다형성 객체를 생성할 때만 사용하라. 그 외의 경우는 다형성을 통해 해결하라
-   서술적 이름을 사용하라
    -   함수가 하는 일을 잘 표현하는 이름을 쓴다
    -   이름이 길어도 괜찮다
    -   2장을 참조하라
-   함수의 인수
    -   인수는 개념을 이해하기 어렵게 한다
    -   이상적인 개수는 0개
    -   적으면 적을수록 좋다
    -   4개 이상부턴 특별한 이유가 없는 한 사용하면 안된다
    -   테스트 관점에서도 인수가 많으면 어렵다
    -   플래그 인수는 추하다. 인수로 bool값을 넘기는 관례는 끔찍하다.
    -   인수가 2~3개 필요하다면 독자적인 클래스 변수로 선언하는것을 고려한다
    -   단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다 ex) writeField(name)
    -   이름에 키워드를 추가하여 인수 순서를 외울 필요가 없도록 한다 ex) assertExpectedEqaulsActual(expected, actual)
-   부수 효과를 일으키지 마라
    -   함수가 한 가지 일을 한다고 약속했으나 **남몰래** 숨겨진 일을 하는 것
    -   예상치 못하게 클래스 변수나 전역 변수를 수정한다거나 함수로 넘어온 인수를 수정하는 경우
    -   부수 효과는 시간적 결합이나 순서 종속석 문제를 초래한다
    -   출력 인수는 피해라. 함수에서 상태를 변경해야 하면 함수가 속한 객체의 상태를 변경하는 방식을 택한다 ex) appendFooter(report) :x: report.appendFooter() :white_check_mark:
-   명령과 조회를 분리하라
    -   함수는 무언가에 답하거나 수행하거나 둘 중 하나만 해야 한다
-   오류 코드보다 예외를 활용하라
    -   오류 코드를 반환하면 해당 함수를 호출하는 부분에서 if문으로 중첩되는 코드가 발생한다
    -   예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되어 깔끔해진다
-   Try/Catch 블록 뽑아내기
    -   try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키고 정상 동작과 처리 동작을 뒤섞는다
    -   try블록과 catch 블록을 각각 별도의 함수로 뽑아내는것이 좋다
    -   오류 처리도 한 가지 작업에 해당한다
-   반복하지 마라
    -   중복은 만악의 근원이다
    -   많은 원칙들이 중복을 없애기 위해 등장했다
-   구조적 프로그래밍
    -   함수는 return문이 하나여야 한다
    -   루프 안에서 break나 continue는 사용하면 안된다
    -   goto는 절대로 사용하지 마라
    -   라고는 하지만 return, break, continue를 여러 차례 사용해도 괜찮다. 오히려 의도를 잘 표현하기 쉽다
-   소프트웨어를 짜는 것은 글짓기와 비슷하다
    -   처음부터 탁 하고 내놓을 수는 없다
    -   코드를 다듬고, 이름을 바꾸고, 함수를 만들고, 중복을 제거해서 좋은 코드가 얻어진다
